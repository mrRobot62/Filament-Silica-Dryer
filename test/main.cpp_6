// LVGL Minimal mit garantiertem Flush (Tick + Forced Refresh)

#include <Arduino.h>
#include <Arduino_GFX_Library.h>
#include <lvgl.h>
#include <esp_timer.h>
#include <esp_heap_caps.h>

// --- Pins / Panel ---
#define LCD_DC   11
#define LCD_CS   10
#define LCD_SCK  12
#define LCD_MOSI 13
#define LCD_RST  1
#define LCD_BL   14
#define LCD_W 170
#define LCD_H 320
#define COL_O 35
#define ROW_O 0

Arduino_DataBus *bus = new Arduino_ESP32SPI(LCD_DC, LCD_CS, LCD_SCK, LCD_MOSI, GFX_NOT_DEFINED);
Arduino_GFX *gfx = new Arduino_ST7789(bus, LCD_RST, 1, true, LCD_W, LCD_H, 0, 0, COL_O, ROW_O);

static lv_display_t *disp = nullptr;
static esp_timer_handle_t tick_timer = nullptr;

// --- Flush mit Debug ---
static void flush_cb(lv_display_t *d, const lv_area_t *a, uint8_t *px)
{
  // Nur Farbe direkt auf das Display schreiben
  static uint16_t c = 0xF800; // Rot
  gfx->fillRect(0, 0, gfx->width(), gfx->height(), c);
  lv_display_flush_ready(d);
  Serial.printf("flush test color=%04X\n", c);
  c ^= 0xFFFF; // zwischen Rot und Cyan wechseln
}

// 1 ms Tick
static void tick_cb(void*) { lv_tick_inc(1); }

void setup() {
  Serial.begin(115200);
  delay(100);
  pinMode(LCD_BL, OUTPUT);
  digitalWrite(LCD_BL, HIGH);

  if (!gfx->begin(60000000)) { Serial.println("GFX begin FAILED"); while(1) delay(100); }
  gfx->invertDisplay(true);
  gfx->fillScreen(BLACK);
  Serial.println("GFX OK");

  // --- LVGL init ---
  lv_init();
  Serial.println("LVGL OK");

  const uint16_t scr_w = gfx->width();   // 320
  const uint16_t scr_h = gfx->height();  // 170

  // DMA-f√§hige interne Buffers (2x 20 Zeilen)
  lv_color_t *buf1 = (lv_color_t*)heap_caps_malloc(scr_w * 20 * sizeof(lv_color_t),
                       MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA | MALLOC_CAP_8BIT);
  lv_color_t *buf2 = (lv_color_t*)heap_caps_malloc(scr_w * 20 * sizeof(lv_color_t),
                       MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA | MALLOC_CAP_8BIT);
  if (!buf1 || !buf2) { Serial.println("LVGL buffer alloc FAILED"); while(1) delay(100); }

  disp = lv_display_create(scr_w, scr_h);
  lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);
  lv_display_set_buffers(disp, buf1, buf2, scr_w * 20 * sizeof(lv_color_t), LV_DISPLAY_RENDER_MODE_PARTIAL);
  lv_display_set_flush_cb(disp, flush_cb);

  // 1 ms Tick via esp_timer
  const esp_timer_create_args_t tcfg = { .callback = &tick_cb, .arg = nullptr, .dispatch_method = ESP_TIMER_TASK, .name = "lv_tick" };
  esp_timer_create(&tcfg, &tick_timer);
  esp_timer_start_periodic(tick_timer, 1000);

  // --- Simple UI ---
  lv_obj_t *bg = lv_obj_create(lv_screen_active());
  lv_obj_set_size(bg, scr_w, scr_h);
  lv_obj_set_style_bg_color(bg, lv_color_hex(0x202040), 0);

  lv_obj_t *label = lv_label_create(lv_screen_active());
  lv_label_set_text(label, "LVGL VISIBLE");
  lv_obj_center(label);

  // Force a full refresh once (falls Tick/Timer gerade erst startet)
  lv_obj_invalidate(lv_screen_active());
  lv_refr_now(disp);

  Serial.println("UI ready");
}

void loop() {
  lv_timer_handler();
  delay(50);
}