// ====== ESP32-S3 HMI + ST7789 170x320 (SPI) — Minimal Display Tester (no LVGL) ======
#include <Arduino.h>
#include <Arduino_GFX_Library.h>

// --- Pins (dein Board) ---
#define LCD_DC 11
#define LCD_CS 10
#define LCD_SCK 12
#define LCD_MOSI 13
#define LCD_RST 1
#define LCD_BL 14

// ST7789 logical size (controller base in portrait)
#define LCD_W 170
#define LCD_H 320

// --- SPI Bus + Panel (korrekte Offsets!) ---
Arduino_DataBus *bus = new Arduino_ESP32SPI(LCD_DC, LCD_CS, LCD_SCK, LCD_MOSI, GFX_NOT_DEFINED);
Arduino_GFX *gfx = new Arduino_ST7789(
    bus, LCD_RST, 1, true,
    170, 320,
    0, 35, // rot0/2
    35, 0  // rot1/3
);

// --- kleine Helferfarben (RGB565) ---
#define C_BLACK 0x0000
#define C_WHITE 0xFFFF
#define C_RED 0xF800
#define C_GREEN 0x07E0
#define C_BLUE 0x001F
#define C_MAGENTA 0xF81F
#define C_YELLOW 0xFFE0
#define C_CYAN 0x07FF
#define C_GRAY 0x8410

// --- Test 1: Rahmen + Kantenmarken (Geometrie/Offsets) ---
void test_frame()
{
    uint16_t W = gfx->width();  // sollte 320 sein
    uint16_t H = gfx->height(); // sollte 170 sein
    gfx->fillScreen(C_BLACK);

    // 2px Magenta-Rahmen
    gfx->drawRect(0, 0, W, H, C_MAGENTA);
    gfx->drawRect(1, 1, W - 2, H - 2, C_MAGENTA);

    // Kantenlinien (weiß)
    gfx->drawFastVLine(0, 0, H, C_WHITE);
    gfx->drawFastVLine(W - 1, 0, H, C_WHITE);
    gfx->drawFastHLine(0, 0, W, C_WHITE);
    gfx->drawFastHLine(0, H - 1, W, C_WHITE);

    // Eck-Pixel farbig
    gfx->drawPixel(0, 0, C_WHITE);
    gfx->drawPixel(W - 1, 0, C_RED);
    gfx->drawPixel(0, H - 1, C_GREEN);
    gfx->drawPixel(W - 1, H - 1, C_BLUE);

    delay(1200);
}

// --- Test 2: Farbbalken (Farbreihenfolge) ---
void test_color_bars()
{
    uint16_t W = gfx->width(), H = gfx->height();
    gfx->fillScreen(C_BLACK);

    const uint16_t cols[] = {C_RED, C_GREEN, C_BLUE, C_CYAN, C_MAGENTA, C_YELLOW, C_WHITE, C_GRAY};
    const int N = sizeof(cols) / sizeof(cols[0]);
    int bw = W / N;

    for (int i = 0; i < N; ++i)
        gfx->fillRect(i * bw, 0, (i == N - 1 ? W - i * bw : bw), H / 2, cols[i]);

    // horizontale Balken unten
    int bh = (H / 2) / N;
    for (int i = 0; i < N; ++i)
        gfx->fillRect(0, H / 2 + i * bh, W, (i == N - 1 ? H - (H / 2 + i * bh) : bh), cols[(N - 1) - i]);

    delay(800);
}

// --- Test 3: Schachbrett (Pixeladressen) ---
void test_checker()
{
    uint16_t W = gfx->width(), H = gfx->height();
    gfx->fillScreen(C_BLACK);
    const int s = 8; // Kachelgröße
    for (int y = 0; y < H; y += s)
        for (int x = 0; x < W; x += s)
            gfx->fillRect(x, y, s, s, ((x / s + y / s) & 1) ? C_GRAY : C_BLACK);
    delay(600);
}

// --- Test 4: Verlauf (Durchsatz / Tearing sichtbar) ---
void test_gradient()
{
    uint16_t W = gfx->width(), H = gfx->height();
    for (int x = 0; x < W; ++x)
    {
        uint16_t c = ((x * 31) / (W - 1)) << 11; // rot-Verlauf
        gfx->drawFastVLine(x, 0, H, c);
    }
    delay(600);
}

// --- Test 5: Bewegt-Rechteck (Teilflächen-Updates) ---
void test_moving_box()
{
    uint16_t W = gfx->width(), H = gfx->height();
    gfx->fillScreen(C_BLACK);
    int boxW = 60, boxH = 40;
    int x = 10, y = 10, vx = 3, vy = 2;

    uint32_t t0 = millis();
    while (millis() - t0 < 3000)
    {
        // altes löschen
        gfx->fillRect(x, y, boxW, boxH, C_BLACK);
        // neue Position
        x += vx;
        y += vy;
        if (x <= 1 || x + boxW >= (int)W - 1)
            vx = -vx;
        if (y <= 1 || y + boxH >= (int)H - 1)
            vy = -vy;
        // neu zeichnen
        gfx->fillRect(x, y, boxW, boxH, C_CYAN);
        gfx->drawRect(x, y, boxW, boxH, C_BLUE);
        delay(10);
    }
}

// --- Setup / Loop ---
void setup()
{
    Serial.begin(115200);
    delay(50);

    pinMode(LCD_BL, OUTPUT);
    digitalWrite(LCD_BL, HIGH);

    // Stabil anfangen: 40 MHz (später 60/80 testen)
    if (!gfx->begin(40000000))
    {
        Serial.println("GFX begin failed");
        while (1)
            delay(100);
    }

    gfx->setRotation(1);                                               // Landscape sicherstellen
    gfx->invertDisplay(false);                                         // neutral
    Serial.printf("GFX size: %u x %u\n", gfx->width(), gfx->height()); // erwartet 320 x 170

    // Testsequenz
    test_frame(); // 1) Offsets/Geometrie
    delay(2000);
    delay(2000);
    test_color_bars(); // 2) Farbreihenfolge
    test_checker();    // 3) Pixeladressierung
    delay(2000);
    test_gradient(); // 4) Durchsatz
    delay(2000);
}

void loop()
{
    test_moving_box(); // 5) bewegt – sollte ohne Artefakte laufen
}