// ============================================================================
// Filament-Dryer ESP32-S3 – Standalone GFX Status UI (no LVGL)
// Display: ST7789 170x320, Landscape artefaktfrei mit:
//   ROT=1, COL_OFFSET=35, ROW_OFFSET=0
//   new Arduino_ST7789(bus, RST, ROT, IPS, 170, 320, 0, 0, COL_OFFSET, ROW_OFFSET)
//
// Features:
// - GFX-Statusanzeige in 2 Spalten (Labels weiß, Werte grün; ON=grün, OFF=rot)
// - Mini-CLI über Serial (Echo, Backspace, Prompt, Befehle siehe `help`)
// - Outputs: SSR, FAN5V, FAN230, FAN-L, LAMP, MOTOR
// - Türkontakt (LOW=geschlossen, HIGH=offen → SSR-Sperre)
// - MAX31856 (K-Typ) via Software-SPI
// - SSR-TPM (zeitproportionale Modulation)
// - Drehencoder (GPIO20=A, GPIO21=B) + Switch (GPIO5), robuster Quadratur-Decoder
// ============================================================================

#include <Arduino.h>
#include <SPI.h>
#include <Arduino_GFX_Library.h>
#include <Adafruit_MAX31856.h>
#include <math.h>
#include "driver/gpio.h"

// ============================== Pin Mapping =================================
// Powerboard I/Os
#define PIN_SSR 7
#define PIN_FAN5V 6
#define PIN_FAN230 15   // P7
#define PIN_LAMP230 16  // P8
#define PIN_MOTOR230 17 // P9
#define PIN_FANL230 18  // P10
#define PIN_DOOR 19     // input, active LOW (LOW=closed, HIGH=open)

// Encoder + Switch (zurück auf GPIO20/21; USB CDC ist deaktiviert)
#define PIN_ENC_A 20
#define PIN_ENC_B 21
#define PIN_ENC_SW 5 // active LOW (wir erkennen Idle-Level dynamisch)

// MAX31856 (Software-SPI, getrennt vom LCD-SPI)
#define PIN_TC_SCK 40
#define PIN_TC_MISO 42
#define PIN_TC_MOSI 48
#define PIN_TC_CS 47

// ST7789 170x320 (ESP32-S3 HMI LCD)
#define PIN_LCD_SCK 12
#define PIN_LCD_MOSI 13
#define PIN_LCD_CS 10
#define PIN_LCD_DC 11
#define PIN_LCD_RST 1
#define PIN_LCD_BL 14

// ---- Panel-Parameter (Landscape, artefaktfrei – Vorgabe) ----
static constexpr uint16_t COL_OFFSET = 35;
static constexpr uint16_t ROW_OFFSET = 0;
static constexpr uint8_t LCD_ROT = 1; // Landscape
static constexpr bool LCD_IPS = true;

// Optional: stabiler SPI-Takt (40 MHz)
static constexpr uint32_t LCD_SPI_HZ = 40000000;

// ============================== Thermocouple ================================
Adafruit_MAX31856 thermo(PIN_TC_CS, PIN_TC_MOSI, PIN_TC_MISO, PIN_TC_SCK);
bool g_thermo_ok = false;

// ============================== Encoder (robust) ============================
// Beide Kanäle lösen denselben Quadratur-Decoder aus.
#define ENC_INVERT_DIR 0                     // bei falscher Richtung → 1
static const uint16_t ENC_DEBOUNCE_US = 120; // leichtes µs-Debounce
static const int8_t STEPS_PER_DETENT = 2;    // 1/2/4 je nach Encoder

volatile long g_enc_count = 0;      // gezählte Rastungen
volatile int8_t g_enc_last_dir = 0; // +1=CW, -1=CCW
volatile uint8_t g_enc_state = 0;   // AB (bit0=A, bit1=B)
volatile int8_t g_quad_accum = 0;   // sammelt Zwischen-Schritte
volatile uint32_t g_enc_last_us = 0;

// DIAG-Zähler (nur auf Abruf via CLI „enc raw“)
volatile uint32_t g_a_edges = 0;
volatile uint32_t g_b_edges = 0;

// Switch
volatile bool g_sw_is_on = false;   // logisch: true=gedrückt
volatile bool g_sw_changed = false; // Edge-Flag für Serial-Log
volatile int g_sw_idle_level = 1;   // wird in setup() ermittelt

static inline uint8_t enc_readAB()
{
    int a = gpio_get_level((gpio_num_t)PIN_ENC_A) & 1;
    int b = gpio_get_level((gpio_num_t)PIN_ENC_B) & 1;
    return (uint8_t)((b << 1) | a);
}

// Quadratur-Übergangstabelle
static const int8_t ENC_TRANS[4][4] = {
    /*prev\curr: 00  01  10  11 */
    /*00*/ {0, +1, -1, 0},
    /*01*/ {-1, 0, 0, +1},
    /*10*/ {+1, 0, 0, -1},
    /*11*/ {0, -1, +1, 0}};

static inline void IRAM_ATTR enc_handle_edge(bool fromA)
{
    if (fromA)
        g_a_edges++;
    else
        g_b_edges++;

    uint32_t now = micros();
    if ((now - g_enc_last_us) < ENC_DEBOUNCE_US)
        return;
    g_enc_last_us = now;

    uint8_t curr = enc_readAB();
    uint8_t prev = g_enc_state;
    int8_t d = ENC_TRANS[prev & 0x03][curr & 0x03];
#if ENC_INVERT_DIR
    d = -d;
#endif
    if (d)
    {
        g_quad_accum += d;
        if (g_quad_accum >= +STEPS_PER_DETENT)
        {
            g_enc_count++;
            g_enc_last_dir = +1;
            g_quad_accum = 0;
        }
        else if (g_quad_accum <= -STEPS_PER_DETENT)
        {
            g_enc_count--;
            g_enc_last_dir = -1;
            g_quad_accum = 0;
        }
    }
    g_enc_state = curr;
}

void IRAM_ATTR isr_encoder_A() { enc_handle_edge(true); }
void IRAM_ATTR isr_encoder_B() { enc_handle_edge(false); }

void IRAM_ATTR isr_switch()
{
    int lvl = gpio_get_level((gpio_num_t)PIN_ENC_SW);
    bool nowOn = (lvl != g_sw_idle_level); // gedrückt = != Idle
    if (nowOn != g_sw_is_on)
    {
        g_sw_is_on = nowOn;
        g_sw_changed = true;
    }
}

// ============================== GFX Objects =================================
Arduino_DataBus *bus = nullptr;
Arduino_GFX *gfx = nullptr;
bool g_gfx_ready = false;

// ============================== Colors (RGB565) =============================
static constexpr uint16_t C_BG = 0x0000;  // black
static constexpr uint16_t C_LBL = 0xFFFF; // white
static constexpr uint16_t C_VAL = 0x07E0; // green
static constexpr uint16_t C_ON = 0x07E0;  // green
static constexpr uint16_t C_OFF = 0xF800; // red
static constexpr uint16_t C_DIM = 0x7BEF; // gray

// ============================== Layout ======================================
// Gesamtbreite 320 px → 2 Spalten à 160 px
static constexpr int16_t COL_W = 160;
static constexpr int16_t INNER_PAD = 5; // ≥ 5 px
// Typografie: Überschrift size=2, Inhalt size=1
static constexpr uint8_t TITLE_TS = 2;
static constexpr uint8_t BODY_TS = 1;
// Zeilenhöhe bei size=1 (8 px Basis + etwas Luft)
static constexpr int16_t LINE_H = 12;
// Label/Value-Aufteilung innerhalb der Spalte
static constexpr int16_t LABEL_W = 70;

int16_t y_origin = 0; // Start-Y nach Überschrift

// ============================== Control / TPM (SSR) =========================
static constexpr uint32_t TPM_WINDOW_MS_DEFAULT = 1000;
static constexpr uint32_t TPM_WINDOW_MS_MIN = 200;
static constexpr uint32_t TPM_WINDOW_MS_MAX = 5000;
static constexpr uint32_t PULSE_MS_MIN = 10;
static constexpr uint32_t PULSE_MS_MAX = 5000;

static uint32_t g_tpm_window_ms = TPM_WINDOW_MS_DEFAULT;
static float g_ssr_duty = 0.0f; // 0..1
static uint32_t g_window_start_ms = 0;
static bool g_tpm_enabled = false; // TPM aktiv?

static inline int door_read() { return digitalRead(PIN_DOOR); } // HIGH=open
static inline void ssr_on() { digitalWrite(PIN_SSR, HIGH); }
static inline void ssr_off() { digitalWrite(PIN_SSR, LOW); }

static void all_off()
{
    g_tpm_enabled = false;
    ssr_off();
    digitalWrite(PIN_FAN5V, LOW);
    digitalWrite(PIN_FAN230, LOW);
    digitalWrite(PIN_FANL230, LOW);
    digitalWrite(PIN_LAMP230, LOW);
    digitalWrite(PIN_MOTOR230, LOW);
}

static void apply_ssr_tpm()
{
    if (!g_tpm_enabled)
        return;
    if (door_read() == HIGH)
    { // Sicherheit: Tür offen → AUS
        ssr_off();
        return;
    }
    const uint32_t now = millis();
    uint32_t elapsed = now - g_window_start_ms;
    if (elapsed >= g_tpm_window_ms)
    {
        g_window_start_ms = now;
        elapsed = 0;
        if (g_ssr_duty > 0.0f)
            ssr_on();
        else
            ssr_off();
    }
    const uint32_t on_ms = (uint32_t)(g_ssr_duty * g_tpm_window_ms);
    if (elapsed >= on_ms)
        ssr_off();
}

// ============================== Helpers =====================================
static inline const char *onoff_txt(int state) { return (state == HIGH) ? "ON" : "OFF"; }
static inline uint16_t onoff_col(int state) { return (state == HIGH) ? C_ON : C_OFF; }
static inline const char *dir_txt(int8_t d) { return (d > 0) ? "CW" : (d < 0) ? "CCW"
                                                                              : "N/A"; }

// ============================== GFX Drawing =================================
static void header(const __FlashStringHelper *title)
{
    gfx->fillScreen(C_BG);
    gfx->setTextWrap(false);
    gfx->setTextSize(TITLE_TS);
    gfx->setTextColor(C_LBL);

    int16_t y = 6;
    gfx->setCursor(6, y);
    gfx->print(title);

    y += (TITLE_TS * 8) + 6;
    gfx->drawFastHLine(0, y, gfx->width(), C_DIM);
    y_origin = y + 6;

    gfx->setTextSize(BODY_TS);
}

static void draw_label_val_in_col(int col_index, int row_index,
                                  const __FlashStringHelper *label,
                                  const char *val, uint16_t col_val)
{
    const int16_t col_x = col_index * COL_W;
    const int16_t content_x = col_x + INNER_PAD;
    const int16_t content_w = COL_W - 2 * INNER_PAD;
    const int16_t y = y_origin + row_index * LINE_H;

    // Label links
    gfx->setTextColor(C_LBL);
    gfx->setCursor(content_x, y);
    gfx->print(label);

    // Value rechts daneben
    gfx->setTextColor(col_val);
    int16_t val_x = content_x + LABEL_W + 6;
    if (val_x < content_x + content_w)
    {
        gfx->setCursor(val_x, y);
        gfx->print(val);
    }
}

static void draw_label_valf_in_col(int col_index, int row_index,
                                   const __FlashStringHelper *label,
                                   float v, uint16_t col_val, uint8_t frac = 2)
{
    const int16_t col_x = col_index * COL_W;
    const int16_t content_x = col_x + INNER_PAD;
    const int16_t content_w = COL_W - 2 * INNER_PAD;
    const int16_t y = y_origin + row_index * LINE_H;

    // Label
    gfx->setTextColor(C_LBL);
    gfx->setCursor(content_x, y);
    gfx->print(label);

    // Value
    gfx->setTextColor(col_val);
    int16_t val_x = content_x + LABEL_W + 6;
    if (val_x < content_x + content_w)
    {
        gfx->setCursor(val_x, y);
        gfx->print(v, frac);
    }
}

static void draw_full()
{
    if (!g_gfx_ready)
        return;

    header(F("Filament Dryer Status"));

    // Linke Spalte
    int col = 0, row = 0;

    // Door
    int door = digitalRead(PIN_DOOR);
    draw_label_val_in_col(col, row++, F("Door"), onoff_txt(door), onoff_col(door));

    // Outputs links
    draw_label_val_in_col(col, row++, F("SSR"), onoff_txt(digitalRead(PIN_SSR)), onoff_col(digitalRead(PIN_SSR)));
    draw_label_val_in_col(col, row++, F("FAN5V"), onoff_txt(digitalRead(PIN_FAN5V)), onoff_col(digitalRead(PIN_FAN5V)));
    draw_label_val_in_col(col, row++, F("FAN230"), onoff_txt(digitalRead(PIN_FAN230)), onoff_col(digitalRead(PIN_FAN230)));
    draw_label_val_in_col(col, row++, F("LAMP"), onoff_txt(digitalRead(PIN_LAMP230)), onoff_col(digitalRead(PIN_LAMP230)));
    draw_label_val_in_col(col, row++, F("MOTOR"), onoff_txt(digitalRead(PIN_MOTOR230)), onoff_col(digitalRead(PIN_MOTOR230)));

    // Rechte Spalte
    col = 1;
    row = 0;
    draw_label_val_in_col(col, row++, F("FAN-L"), onoff_txt(digitalRead(PIN_FANL230)), onoff_col(digitalRead(PIN_FANL230)));

    // Encoder & Switch
    long enc = g_enc_count;
    int8_t dir = g_enc_last_dir;
    char buf[32];
    snprintf(buf, sizeof(buf), "%ld (%s)", enc, dir_txt(dir));
    draw_label_val_in_col(col, row++, F("Encoder"), buf, C_VAL);

    draw_label_val_in_col(col, row++, F("Switch"), g_sw_is_on ? "ON" : "OFF", g_sw_is_on ? C_ON : C_OFF);

    // Temperatur
    float tc = NAN, cj = NAN;
    if (g_thermo_ok)
    {
        tc = thermo.readThermocoupleTemperature();
        cj = thermo.readCJTemperature();
    }
    if (!isnan(tc))
    {
        draw_label_valf_in_col(col, row++, F("Temp"), tc, C_VAL, 2);
        draw_label_valf_in_col(col, row++, F("CJ"), cj, C_VAL, 2);
    }
    else
    {
        draw_label_val_in_col(col, row++, F("Temp"), "N/A", C_OFF);
    }
}

// Nur redraw bei Änderung (~300 ms)
static void gfx_tick()
{
    static uint32_t last_ms = 0;
    uint32_t now = millis();
    if (now - last_ms < 300)
        return;
    last_ms = now;

    static int last_door = -1, last_ssr = -1, last_f5 = -1, last_f230 = -1, last_lamp = -1, last_motor = -1, last_fanl = -1;
    static long last_enc = LONG_MIN;
    static int8_t last_dir = 0;
    static bool last_sw = false;
    static float last_tc = NAN;

    int door = digitalRead(PIN_DOOR);
    int ssr = digitalRead(PIN_SSR);
    int f5 = digitalRead(PIN_FAN5V);
    int f230 = digitalRead(PIN_FAN230);
    int lamp = digitalRead(PIN_LAMP230);
    int motor = digitalRead(PIN_MOTOR230);
    int fanl = digitalRead(PIN_FANL230);
    long enc = g_enc_count;
    int8_t dir = g_enc_last_dir;
    bool sw = g_sw_is_on;

    float tc = last_tc, cj = NAN;
    if (g_thermo_ok && (now % 1000 < 300))
    {
        tc = thermo.readThermocoupleTemperature();
        cj = thermo.readCJTemperature();
        (void)cj;
    }

    bool changed =
        door != last_door || ssr != last_ssr || f5 != last_f5 || f230 != last_f230 ||
        lamp != last_lamp || motor != last_motor || fanl != last_fanl ||
        enc != last_enc || dir != last_dir || sw != last_sw ||
        (g_thermo_ok && (isnan(tc) != isnan(last_tc) || (!isnan(tc) && fabsf(tc - last_tc) > 0.25f)));

    if (changed)
    {
        draw_full();
        last_door = door;
        last_ssr = ssr;
        last_f5 = f5;
        last_f230 = f230;
        last_lamp = lamp;
        last_motor = motor;
        last_fanl = fanl;
        last_enc = enc;
        last_dir = dir;
        last_sw = sw;
        last_tc = tc;
    }
}

// ============================== Mini-CLI ====================================
static String g_line;

static void print_help()
{
    Serial.println(F("\nCommands:"));
    Serial.println(F("  help                      - show this help"));
    Serial.println(F("  stat                      - print current states to serial"));
    Serial.println(F("  refresh                   - reinit screen and redraw"));
    Serial.println(F("  temp                      - read MAX31856 temperature"));
    Serial.println(F("  door                      - read door input (LOW=closed, HIGH=open)"));
    Serial.println(F("  ssr on|off                - heater SSR on/off (direct)"));
    Serial.println(F("  ssr duty <0-100>          - enable TPM, set duty percent"));
    Serial.println(F("  window <ms>               - set TPM window (200..5000, default 1000)"));
    Serial.println(F("  fan5 on|off               - 5V fan (P5)"));
    Serial.println(F("  fan230 on|off             - 230V fan (P7)"));
    Serial.println(F("  fanl on|off               - 230V fan-L (P10)"));
    Serial.println(F("  lamp on|off               - 230V lamp (P8)"));
    Serial.println(F("  motor on|off              - 230V motor (P9)"));
    Serial.println(F("  pulse <tgt> <ms>          - pulse: ssr|fan5|fan230|fanl|lamp|motor"));
    Serial.println(F("  enc stat                  - show encoder count & last direction"));
    Serial.println(F("  enc reset                 - reset encoder count to zero"));
    Serial.println(F("  enc raw                   - print raw A/B edges and state once"));
    Serial.println(F("  alloff                    - switch off all outputs"));
}

static void print_stat()
{
    Serial.println(F("\n--- System Status ---"));
    Serial.printf("Door : %s\n", (digitalRead(PIN_DOOR) == LOW) ? "CLOSED (LOW)" : "OPEN (HIGH)");
    Serial.printf("SSR  : %s\n", onoff_txt(digitalRead(PIN_SSR)));
    Serial.printf("FAN5V: %s\n", onoff_txt(digitalRead(PIN_FAN5V)));
    Serial.printf("FAN230: %s\n", onoff_txt(digitalRead(PIN_FAN230)));
    Serial.printf("LAMP : %s\n", onoff_txt(digitalRead(PIN_LAMP230)));
    Serial.printf("MOTOR: %s\n", onoff_txt(digitalRead(PIN_MOTOR230)));
    Serial.printf("FAN-L: %s\n", onoff_txt(digitalRead(PIN_FANL230)));

    long c = g_enc_count;
    int8_t d = g_enc_last_dir;
    Serial.printf("Encoder: count=%ld last=%s\n", c, dir_txt(d));
    Serial.printf("Switch : %s\n", g_sw_is_on ? "ON" : "OFF");

    if (g_thermo_ok)
    {
        float tc = thermo.readThermocoupleTemperature();
        float cj = thermo.readCJTemperature();
        Serial.printf("Temp: %.2f C (CJ: %.2f C)\n", tc, cj);
    }
    else
    {
        Serial.println(F("Temp: MAX31856 not initialized / not found."));
    }
    Serial.println(F("----------------------\n"));
}

static void parse_line(String s)
{
    s.trim();
    if (s.length() == 0)
        return;

    String cmd, a1, a2;
    int sp = s.indexOf(' ');
    if (sp < 0)
    {
        cmd = s;
    }
    else
    {
        cmd = s.substring(0, sp);
        a1 = s.substring(sp + 1);
        a1.trim();
    }
    int sp2 = a1.indexOf(' ');
    if (sp2 >= 0)
    {
        a2 = a1.substring(sp2 + 1);
        a2.trim();
        a1 = a1.substring(0, sp2);
    }

    cmd.toLowerCase();
    a1.toLowerCase();
    a2.toLowerCase();

    if (cmd == "help" || cmd == "?")
    {
        print_help();
    }
    else if (cmd == "stat")
    {
        print_stat();
    }
    else if (cmd == "refresh")
    {
        if (bus)
        {
            delete bus;
            bus = nullptr;
        }
        if (gfx)
        {
            delete gfx;
            gfx = nullptr;
        }
        bus = new Arduino_ESP32SPI(PIN_LCD_DC, PIN_LCD_CS, PIN_LCD_SCK, PIN_LCD_MOSI, -1);
        gfx = new Arduino_ST7789(bus, PIN_LCD_RST, LCD_ROT, LCD_IPS, 170, 320, 0, 0, COL_OFFSET, ROW_OFFSET);
        pinMode(PIN_LCD_BL, OUTPUT);
        digitalWrite(PIN_LCD_BL, HIGH);
        g_gfx_ready = gfx->begin(LCD_SPI_HZ);
        if (g_gfx_ready)
        {
            gfx->invertDisplay(false);
            gfx->setTextWrap(false);
            delay(2);
            gfx->setTextSize(BODY_TS);
            draw_full();
            Serial.println(F("Screen refreshed."));
        }
        else
        {
            Serial.println(F("Screen init failed."));
        }
    }
    else if (cmd == "temp")
    {
        if (!g_thermo_ok)
            Serial.println(F("MAX31856 not initialized / not found."));
        else
            Serial.printf("Thermo: %.2f C (CJ: %.2f C)\n",
                          thermo.readThermocoupleTemperature(),
                          thermo.readCJTemperature());
    }
    else if (cmd == "door")
    {
        Serial.println((door_read() == LOW) ? F("CLOSED (LOW)") : F("OPEN (HIGH)"));
    }
    else if (cmd == "ssr")
    {
        if (a1 == "on")
        {
            if (door_read() == HIGH)
                Serial.println(F("Door OPEN → SSR blocked."));
            else
            {
                g_tpm_enabled = false;
                ssr_on();
                Serial.println(F("SSR ON"));
            }
        }
        else if (a1 == "off")
        {
            g_tpm_enabled = false;
            ssr_off();
            Serial.println(F("SSR OFF"));
        }
        else if (a1 == "duty")
        {
            float pct = a2.toFloat();
            if (pct < 0)
                pct = 0;
            if (pct > 100)
                pct = 100;
            if (door_read() == HIGH)
            {
                Serial.println(F("Door OPEN → SSR blocked."));
            }
            else
            {
                g_ssr_duty = pct / 100.0f;
                g_tpm_enabled = true;
                g_window_start_ms = millis();
                Serial.printf("SSR duty set to %.1f%% (TPM enabled)\n", pct);
            }
        }
        else
        {
            Serial.println(F("Usage: ssr on|off | ssr duty <0-100>"));
        }
    }
    else if (cmd == "window")
    {
        long w = a1.toInt();
        if (w < (long)TPM_WINDOW_MS_MIN)
            w = TPM_WINDOW_MS_MIN;
        if (w > (long)TPM_WINDOW_MS_MAX)
            w = TPM_WINDOW_MS_MAX;
        g_tpm_window_ms = (uint32_t)w;
        Serial.printf("TPM window = %u ms\n", g_tpm_window_ms);
    }
    else if (cmd == "fan5")
    {
        digitalWrite(PIN_FAN5V, (a1 == "on") ? HIGH : LOW);
        Serial.printf("fan5V %s\n", a1.c_str());
    }
    else if (cmd == "fan230")
    {
        digitalWrite(PIN_FAN230, (a1 == "on") ? HIGH : LOW);
        Serial.printf("fan230 %s\n", a1.c_str());
    }
    else if (cmd == "fanl")
    {
        digitalWrite(PIN_FANL230, (a1 == "on") ? HIGH : LOW);
        Serial.printf("fanL %s\n", a1.c_str());
    }
    else if (cmd == "lamp")
    {
        digitalWrite(PIN_LAMP230, (a1 == "on") ? HIGH : LOW);
        Serial.printf("lamp %s\n", a1.c_str());
    }
    else if (cmd == "motor")
    {
        digitalWrite(PIN_MOTOR230, (a1 == "on") ? HIGH : LOW);
        Serial.printf("motor %s\n", a1.c_str());
    }
    else if (cmd == "pulse")
    {
        uint32_t ms = (uint32_t)a2.toInt();
        if (ms < PULSE_MS_MIN)
            ms = PULSE_MS_MIN;
        if (ms > PULSE_MS_MAX)
            ms = PULSE_MS_MAX;
        if (a1 == "ssr")
        {
            if (door_read() == HIGH)
            {
                Serial.println(F("Door OPEN → SSR blocked."));
            }
            else
            {
                digitalWrite(PIN_SSR, HIGH);
                delay(ms);
                digitalWrite(PIN_SSR, LOW);
            }
        }
        else if (a1 == "fan5")
        {
            digitalWrite(PIN_FAN5V, HIGH);
            delay(ms);
            digitalWrite(PIN_FAN5V, LOW);
        }
        else if (a1 == "fan230")
        {
            digitalWrite(PIN_FAN230, HIGH);
            delay(ms);
            digitalWrite(PIN_FAN230, LOW);
        }
        else if (a1 == "fanl")
        {
            digitalWrite(PIN_FANL230, HIGH);
            delay(ms);
            digitalWrite(PIN_FANL230, LOW);
        }
        else if (a1 == "lamp")
        {
            digitalWrite(PIN_LAMP230, HIGH);
            delay(ms);
            digitalWrite(PIN_LAMP230, LOW);
        }
        else if (a1 == "motor")
        {
            digitalWrite(PIN_MOTOR230, HIGH);
            delay(ms);
            digitalWrite(PIN_MOTOR230, LOW);
        }
        else
        {
            Serial.println(F("Unknown target. Use: ssr|fan5|fan230|fanl|lamp|motor"));
        }
    }
    else if (cmd == "enc")
    {
        if (a1 == "stat")
        {
            long c = g_enc_count;
            int8_t d = g_enc_last_dir;
            Serial.printf("Encoder: count=%ld  last=%s\n", c, (d > 0) ? "CW" : (d < 0) ? "CCW"
                                                                                       : "N/A");
            Serial.printf("Switch : %s\n", g_sw_is_on ? "ON" : "OFF");
        }
        else if (a1 == "reset")
        {
            g_enc_count = 0;
            g_enc_last_dir = 0;
            g_quad_accum = 0;
            Serial.println(F("Encoder count reset."));
        }
        else if (a1 == "raw")
        {
            uint8_t ab = enc_readAB();
            Serial.printf("RAW: A=%d B=%d  A_edges=%u B_edges=%u  count=%ld last=%s accum=%d\n",
                          ab & 1, (ab >> 1) & 1, (unsigned)g_a_edges, (unsigned)g_b_edges,
                          g_enc_count, (g_enc_last_dir > 0) ? "CW" : (g_enc_last_dir < 0) ? "CCW"
                                                                                          : "N/A",
                          (int)g_quad_accum);
        }
        else
        {
            Serial.println(F("Usage: enc stat | enc reset | enc raw"));
        }
    }
    else if (cmd == "alloff")
    {
        all_off();
        Serial.println(F("All outputs OFF."));
    }
    else
    {
        Serial.println(F("Unknown command. Type 'help'."));
    }

    Serial.print(F("> "));
}

// ============================== Arduino Entry ===============================
void setup()
{
    Serial.begin(115200);
    delay(50);

    // Safe outputs
    pinMode(PIN_SSR, OUTPUT);
    digitalWrite(PIN_SSR, LOW);
    pinMode(PIN_FAN5V, OUTPUT);
    digitalWrite(PIN_FAN5V, LOW);
    pinMode(PIN_FAN230, OUTPUT);
    digitalWrite(PIN_FAN230, LOW);
    pinMode(PIN_LAMP230, OUTPUT);
    digitalWrite(PIN_LAMP230, LOW);
    pinMode(PIN_MOTOR230, OUTPUT);
    digitalWrite(PIN_MOTOR230, LOW);
    pinMode(PIN_FANL230, OUTPUT);
    digitalWrite(PIN_FANL230, LOW);
    pinMode(PIN_DOOR, INPUT_PULLUP);

    // Encoder
    pinMode(PIN_ENC_A, INPUT_PULLUP);
    pinMode(PIN_ENC_B, INPUT_PULLUP);
    pinMode(PIN_ENC_SW, INPUT_PULLUP);
    gpio_pullup_en((gpio_num_t)PIN_ENC_A);
    gpio_pullup_en((gpio_num_t)PIN_ENC_B);
    gpio_pullup_en((gpio_num_t)PIN_ENC_SW);
    delay(2); // Stabilisierung

    g_enc_state = enc_readAB();
    g_quad_accum = 0;
    g_enc_last_us = micros();

    g_sw_idle_level = gpio_get_level((gpio_num_t)PIN_ENC_SW);
    g_sw_is_on = (gpio_get_level((gpio_num_t)PIN_ENC_SW) != g_sw_idle_level);

    // Beide Kanäle auf den gleichen Decoder
    attachInterrupt(digitalPinToInterrupt(PIN_ENC_A), isr_encoder_A, CHANGE);
    attachInterrupt(digitalPinToInterrupt(PIN_ENC_B), isr_encoder_B, CHANGE);
    attachInterrupt(digitalPinToInterrupt(PIN_ENC_SW), isr_switch, CHANGE);

    // Thermocouple
    g_thermo_ok = thermo.begin();
    if (g_thermo_ok)
    {
        thermo.setThermocoupleType(MAX31856_TCTYPE_K);
        thermo.setNoiseFilter(MAX31856_NOISE_FILTER_50HZ);
    }

    // GFX init (artefaktfreie Landscape-Init)
    bus = new Arduino_ESP32SPI(PIN_LCD_DC, PIN_LCD_CS, PIN_LCD_SCK, PIN_LCD_MOSI, -1);
    gfx = new Arduino_ST7789(bus, PIN_LCD_RST, LCD_ROT, LCD_IPS, 170, 320, 0, 0, COL_OFFSET, ROW_OFFSET);
    pinMode(PIN_LCD_BL, OUTPUT);
    digitalWrite(PIN_LCD_BL, HIGH);

    g_gfx_ready = gfx->begin(LCD_SPI_HZ);
    if (g_gfx_ready)
    {
        gfx->invertDisplay(false);
        gfx->setTextWrap(false);
        delay(2);
        gfx->setTextSize(BODY_TS);
        draw_full();
    }

    Serial.println();
    Serial.println(F("=== Filament-Dryer – GFX Status UI (Landscape 170x320, 2 columns) ==="));
    print_help();
    Serial.print(F("\n> "));
}

void loop()
{
    // TPM-SSR
    apply_ssr_tpm();

    // Screen-Refresh bei Änderungen
    gfx_tick();

    // Eventlog: Encoder & Switch (kompakt)
    static long lastPrintedCount = 0;
    if (g_enc_count != lastPrintedCount)
    {
        long delta = g_enc_count - lastPrintedCount;
        Serial.printf("Encoder: %ld ticks (%s)\r\n", delta, (delta > 0) ? "CW" : "CCW");
        lastPrintedCount = g_enc_count;
    }
    if (g_sw_changed)
    {
        g_sw_changed = false;
        Serial.printf("Switch: %s\r\n", g_sw_is_on ? "ON" : "OFF");
    }

    // Mini-CLI (Echo, Backspace, Prompt)
    while (Serial.available())
    {
        char c = (char)Serial.read();
        if (c == '\r')
            continue; // CR ignorieren
        if (c == '\n')
        {
            Serial.println();
            String cmd = g_line;
            g_line.remove(0);
            parse_line(cmd);
        }
        else if (c == '\b' || c == 127)
        {
            if (g_line.length() > 0)
            {
                g_line.remove(g_line.length() - 1);
                Serial.print("\b \b");
            }
        }
        else
        {
            g_line += c;
            Serial.print(c);
            if (g_line.length() > 160)
            {
                g_line.remove(0);
                Serial.println(F("\n(Line cleared: too long)"));
                Serial.print(F("> "));
            }
        }
    }
}