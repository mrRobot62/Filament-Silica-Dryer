/*
 * FILE: ui_events.c
 * AUTHOR: User
 * DESCRIPTION: User-defined event handlers. This file is generated by the
 *              tool and should be used to implement the logic for UI events.
 *              It will not be overwritten if it already exists.
 */

#include "ui_events.h"
#include "../logging/log_events.h"
#include "ui.h"

State g_state;

State getGState() {
  return g_state;
}

void setGState(State state) {
  g_state = state;
}

// Farben (gern anpassen)
static inline lv_color_t C_FG_DEFAULT() {
  return lv_color_hex(0xF9FAFB);
} // weiß
static inline lv_color_t C_FG_FOCUS() {
  return lv_palette_main(LV_PALETTE_BLUE);
}
static inline lv_color_t C_BG_FOCUS() {
  return lv_palette_main(LV_PALETTE_BLUE);
}

// ============================== Encoder ==============================
void on_btnStart_Clicked(lv_event_t *e) {
  EVENT_DBG("on_btnStart_Clicked");

  if (on_click_btnStart)
    on_click_btnStart(e);
}

void on_btnCancel_Clicked(lv_event_t *e) {
  EVENT_DBG("on_btnCancel_Clicked");
  if (on_click_btnCancel)
    on_click_btnCancel(e);
}

//-------------------------------------------------

void on_enter_state(State state) {
  switch (state) {
  case State::IDLE:
    Serial.println("STATE::IDLE entered");
    break;
  }
}

State stateChanged(State currentState) {
  State newState = currentState;
  // switch (currentState) { case State::IDLE: }

  return newState;
}

static void enter_time_edit(UiContext *ui, lv_obj_t *sb, EditTarget target) {
  /* Helper für Time-SpinBoxes im Edit-Modus */
  if (!ui || !sb)
    return;

  setGState(State::EDIT);
  s_editTarget = target;
  lv_obj_set_style_bg_opa(sb, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_bg_color(sb, lv_color_hex(0x2C7DFA), LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_text_color(sb, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);

  // optional: Outline weg im Edit-Mode
  lv_obj_set_style_border_width(sb, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
}

static void exit_time_edit(UiContext *ui, lv_obj_t *sb) {
  /* helper für Time-SpinBoxes wenn EXIT*/
  if (!ui || !sb)
    return;

  setGState(State::IDLE);
  s_editTarget = EditTarget::None;

  // Style zurück auf „nur Fokus-Rahmen / neutral“
  // (vereinfachte Version – du kannst das später in deine
  //  generische Fokus-Logik integrieren)
  lv_obj_set_style_bg_opa(sb, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_bg_color(sb, lv_color_black(), LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_text_color(sb, lv_color_hex(0xF9FAFB), LV_PART_MAIN | LV_STATE_DEFAULT);
}

UiFocusTarget ui_get_focused_target(const UiContext *ui) {
  /*
  Helper Funktion um das fokussierte Widget zu ermitteln "
  */

  if (!ui || !ui->group)
    return UiFocusTarget::None;

  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return UiFocusTarget::None;

  if (f == ui->spnTimeHH)
    return UiFocusTarget::TimeHH;
  if (f == ui->spnTimeMM)
    return UiFocusTarget::TimeMM;
  if (f == ui->spnTimeSS)
    return UiFocusTarget::TimeSS;
  if (f == ui->spnTemp)
    return UiFocusTarget::Temp;
  if (f == ui->rollerType)
    return UiFocusTarget::TypeRoller;
  if (f == ui->btnStart)
    return UiFocusTarget::BtnStart;
  if (f == ui->btnCancel)
    return UiFocusTarget::BtnCancel;

  return UiFocusTarget::None;
}

void shortClickDetected(UiContext *ui) {
  EVENT_DBG("SingleClick...");
  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return;

  // Buttons bleiben event-basiert. Widgets sind State-Basiert
  if (f == ui->btnCancel || f == ui->btnStart) {
    lv_obj_send_event(f, LV_EVENT_CLICKED, NULL);
    return;
  }

  UiFocusTarget target = ui_get_focused_target(ui);
  if (getGState() == State::IDLE) {
    switch (target) {
    case UiFocusTarget::TimeMM:
      enter_time_edit(ui, f, EditTarget::TimeMM);
      return;
      break;
    case UiFocusTarget::TimeSS:
      enter_time_edit(ui, f, EditTarget::TimeSS);
      return;
      break;
    case UiFocusTarget::TimeHH:
      enter_time_edit(ui, f, EditTarget::TimeHH);
      return;
      break;

    case UiFocusTarget::Temp:
      // Temperaturedit
      break;

    case UiFocusTarget::TypeRoller:
      // Roller-Edit-Mode (Filamentauswahl)
      if (getGState() == State::IDLE) {
        setGState(State::EDIT);
        s_editTarget = EditTarget::RollerType;
        // Style für Edit-Mode setzen
        ui_update_roller_focus_style(ui, /*edit=*/true);
        EVENT_INFO("Change global state to State::EDIT");
        return;
      }
      break;
    default:
      break;
    }
  }
  if (getGState() == State::EDIT) {
    // optionales zusatzverhalten
    return;
  }
}

void doubleClickDeteced(UiContext *ui) {
  EVENT_DBG("DoubleClick...");
}

void longClickDetected(UiContext *ui) {
  if (!ui || !ui->group)
    return;

  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return;

  // Wir interessieren uns im Moment nur für EditMode+Roller
  if (getGState() == State::EDIT && s_editTarget == EditTarget::RollerType && f == ui->rollerType) {

    // 1) Aktuelle Auswahl auslesen
    int sel = lv_roller_get_selected(ui->rollerType);

    // 2) Business-Logik: Auswahl merken / Callback
    //    z.B. in deinem UiContext:
    ui->selectedFilamentIndex = sel;
    // oder falls du einen Callback hast:
    // if (on_filament_selected) on_filament_selected(sel);

    // 3) Zurück in Navigation
    setGState(State::IDLE);
    s_editTarget = EditTarget::None;

    ui_update_roller_focus_style(ui, /*edit=*/false);
    EVENT_INFO("LongClick - state back to IDLE");
    // optional:
    // lv_group_set_editing(ui->group, false);

    return;
  }
}

void ui_event_init() {

  // RotarySwitch: stabile Parameter
  rs.begin(true);
  rs.setDebounceMs(15);
  rs.setDoubleClickWindowMs(300);
  rs.setLongClickMs(1500);
  rs.setStep(1);
  rs.setReverseDirection(true); // CW = positiv
  rs.setButtonActiveLow(false); // dein Board: pressed = HIGH

  // Default-State
  g_state = State::IDLE;
}

void ui_event_task() {
  rs.update();
  UiContext *ui = ui_get();

  // 1) intent-first -
  if (rs.wasDoubleClicked()) {
    doubleClickDeteced(ui);
  } else if (rs.wasLongClicked()) {
    longClickDetected(ui);
  } else if (rs.wasShortClicked()) {
    shortClickDetected(ui);
  }

  // Encoder Drehbewegung auswerten und Focus setzen
  long newPos;
  if (rs.pollPositionChange(newPos)) {
    static long lastPos = newPos; // initialisierung nur 1x weil static
    long diff = newPos - lastPos;
    lastPos = newPos;
    if (diff == 0)
      return;

    int steps = diff > 0 ? diff : -diff;
    int8_t dir = diff > 0 ? +1 : -1;
    EVENT_DBG("STATE: %d, ENC: %d|%d - Diff: %d  - Dir: %d - Step: %d\n", getGState(), (int)newPos, lastPos, diff, dir,
              steps);
    lv_obj_t *f = lv_group_get_focused(ui->group);

    for (uint8_t i = 0; i < steps; ++i) {
      // Serial.println("switch(getGState())");
      switch (getGState()) {
      case State::COOLING: {
        break;
      }
      case State::EDIT: {
        // spinBoxen verarbeiten
        auto spin_step = [&](lv_obj_t *sb) {
          if (!sb)
            return;
          if (dir > 0)
            lv_spinbox_increment(sb);
          else
            lv_spinbox_decrement(sb);
        };
        if (s_editTarget == EditTarget::TimeHH && f == ui->spnTimeHH) {
          spin_step(ui_spnTimeHH);
          return;
        }
        if (s_editTarget == EditTarget::TimeMM && f == ui->spnTimeMM) {
          spin_step(ui_spnTimeMM);
          return;
        }
        if (s_editTarget == EditTarget::TimeSS && f == ui->spnTimeSS) {
          spin_step(ui_spnTimeSS);
          return;
        }

        // rollerType verarbeiten (Filamentauswahl)
        if (ui->rollerType) {
          int sel = lv_roller_get_selected(ui->rollerType);
          sel += dir;
          int cnt = lv_roller_get_option_cnt(ui->rollerType);
          if (sel < 0)
            sel = 0;
          if (sel >= cnt)
            sel = cnt - 1;
          lv_roller_set_selected(ui->rollerType, sel, LV_ANIM_ON);
        }
        break;
      }
      case State::RUN: {
        break;
      }
      case State::ERROR: {
        break;
      }
      case State::IDLE: {
        if (dir > 0) { // nächstes Widget den focus geben
          EVENT_DBG("1 Focus next...");
          lv_group_focus_next(ui->group);
          EVENT_DBG("2 Focus next...");
        } else { // vorherigem Widget den Focus zurück geben
          lv_group_focus_prev(ui->group);
          EVENT_DBG("Focus prev..");
        }
        break;
      }
      default:
        if (dir > 0) {
          Serial.println("default focus next...");
          lv_group_focus_next(ui->group);
        }
      } // switch
    }
  } // pollPositionChange
}