/*
 * FILE: ui_events.c
 * AUTHOR: User
 * DESCRIPTION: User-defined event handlers. This file is generated by the
 *              tool and should be used to implement the logic for UI events.
 *              It will not be overwritten if it already exists.
 */

#include "ui_events.h"
#include "../logging/log_events.h"
#include "ui.h"

State g_state;

State getGState() {
  return g_state;
}

void setGState(State state) {
  g_state = state;
}

// Farben (gern anpassen)
static inline lv_color_t C_FG_DEFAULT() {
  return lv_color_hex(0xF9FAFB);
} // weiß
static inline lv_color_t C_FG_FOCUS() {
  return lv_palette_main(LV_PALETTE_BLUE);
}
static inline lv_color_t C_BG_FOCUS() {
  return lv_palette_main(LV_PALETTE_BLUE);
}

// ============================== Encoder ==============================

// void on_rolType_Clicked(lv_event_t *e) {
//   EVENT_DBG("on_rolType_Clicked");
//   if (on_click_rolType)
//     on_click_rolType(e);
// }

// void on_rolType_Focused(lv_event_t *e) {
//   // Your code here
// }

// void on_rolType_ValueChanged(lv_event_t *e) {
//   if (on_change_rolType)
//     on_change_rolType(e);
// }

void on_btnStart_Clicked(lv_event_t *e) {
  EVENT_DBG("on_btnStart_Clicked");

  if (on_click_btnStart)
    on_click_btnStart(e);
}

// void on_btnStart_Focused(lv_event_t *e) {
//   // Your code here
// }

// void on_btnCancel_Focused(lv_event_t *e) {
//   // Your code here
// }

void on_btnCancel_Clicked(lv_event_t *e) {
  EVENT_DBG("on_btnCancel_Clicked");
  if (on_click_btnCancel)
    on_click_btnCancel(e);
}

//-------------------------------------------------

void on_enter_state(State state) {
  switch (state) {
  case State::IDLE:
    Serial.println("STATE::IDLE entered");
    break;
  }
}

State stateChanged(State currentState) {
  State newState = currentState;
  // switch (currentState) { case State::IDLE: }

  return newState;
}

UiFocusTarget ui_get_focused_target(const UiContext *ui) {
  /*
  Helper Funktion um das fokussierte Widget zu ermitteln "
  */

  if (!ui || !ui->group)
    return UiFocusTarget::None;

  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return UiFocusTarget::None;

  if (f == ui->spnTimeHH)
    return UiFocusTarget::TimeHH;
  if (f == ui->spnTimeMM)
    return UiFocusTarget::TimeMM;
  if (f == ui->spnTimeSS)
    return UiFocusTarget::TimeSS;
  if (f == ui->spnTemp)
    return UiFocusTarget::Temp;
  if (f == ui->rollerType)
    return UiFocusTarget::TypeRoller;
  if (f == ui->btnStart)
    return UiFocusTarget::BtnStart;
  if (f == ui->btnCancel)
    return UiFocusTarget::BtnCancel;

  return UiFocusTarget::None;
}

void shortClickDetected(UiContext *ui) {
  EVENT_DBG("SingleClick...");
  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return;

  // Buttons bleiben event-basiert. Widgets sind State-Basiert
  if (f == ui->btnCancel || f == ui->btnStart) {
    lv_obj_send_event(f, LV_EVENT_CLICKED, NULL);
    return;
  }

  UiFocusTarget target = ui_get_focused_target(ui);

  switch (target) {
  case UiFocusTarget::TimeHH:
  case UiFocusTarget::TimeMM:
  case UiFocusTarget::TimeSS:
    // Time-Edit-Modus toggeln
    // z.B. s_edit_mode_time = !s_edit_mode_time;
    // evtl. Cursor aktivieren, Style anpassen, etc.
    // ui_update_time_edit_style(ui, target);
    break;

  case UiFocusTarget::Temp:
    // Temperaturedit
    break;

  case UiFocusTarget::TypeRoller:
    // Roller-Edit-Mode (Filamentauswahl)
    if (getGState() == State::IDLE) {
      setGState(State::EDIT);
      s_editTarget = EditTarget::RollerType;
      // Style für Edit-Mode setzen
      ui_update_roller_focus_style(ui, /*edit=*/true);
      EVENT_INFO("Change global state to State::EDIT");
      return;
    }
    break;
  default:
    break;
  }

  if (getGState() == State::EDIT) {
    // optionales zusatzverhalten
    return;
  }
}

void doubleClickDeteced(UiContext *ui) {
  EVENT_DBG("DoubleClick...");
}

void longClickDetected(UiContext *ui) {
  if (!ui || !ui->group)
    return;

  lv_obj_t *f = lv_group_get_focused(ui->group);
  if (!f)
    return;

  // Wir interessieren uns im Moment nur für EditMode+Roller
  if (getGState() == State::EDIT && s_editTarget == EditTarget::RollerType && f == ui->rollerType) {

    // 1) Aktuelle Auswahl auslesen
    int sel = lv_roller_get_selected(ui->rollerType);

    // 2) Business-Logik: Auswahl merken / Callback
    //    z.B. in deinem UiContext:
    ui->selectedFilamentIndex = sel;
    // oder falls du einen Callback hast:
    // if (on_filament_selected) on_filament_selected(sel);

    // 3) Zurück in Navigation
    setGState(State::IDLE);
    s_editTarget = EditTarget::None;

    ui_update_roller_focus_style(ui, /*edit=*/false);
    EVENT_INFO("LongClick - state back to IDLE");
    // optional:
    // lv_group_set_editing(ui->group, false);

    return;
  }
}

void ui_event_init() {

  // RotarySwitch: stabile Parameter
  rs.begin(true);
  rs.setDebounceMs(15);
  rs.setDoubleClickWindowMs(300);
  rs.setLongClickMs(1500);
  rs.setStep(1);
  rs.setReverseDirection(true); // CW = positiv
  rs.setButtonActiveLow(false); // dein Board: pressed = HIGH

  // Default-State
  g_state = State::IDLE;
}

void ui_event_task() {
  rs.update();
  UiContext *ui = ui_get();

  // 1) intent-first -
  if (rs.wasDoubleClicked()) {
    doubleClickDeteced(ui);
  } else if (rs.wasLongClicked()) {
    longClickDetected(ui);
  } else if (rs.wasShortClicked()) {
    shortClickDetected(ui);
  }

  // Encoder Drehbewegung auswerten und Focus setzen
  long newPos;
  if (rs.pollPositionChange(newPos)) {
    static long lastPos = newPos; // initialisierung nur 1x weil static
    long diff = newPos - lastPos;
    lastPos = newPos;
    if (diff == 0)
      return;

    int steps = diff > 0 ? diff : -diff;
    int8_t dir = diff > 0 ? +1 : -1;
    EVENT_DBG("STATE: %d, ENC: %d|%d - Diff: %d  - Dir: %d - Step: %d\n", getGState(), (int)newPos, lastPos, diff, dir,
              steps);
    for (uint8_t i = 0; i < steps; ++i) {
      // Serial.println("switch(getGState())");
      switch (getGState()) {
      case State::COOLING: {
        break;
      }
      case State::EDIT: {
        if (ui->rollerType) {
          int sel = lv_roller_get_selected(ui->rollerType);
          sel += dir;
          int cnt = lv_roller_get_option_cnt(ui->rollerType);
          if (sel < 0)
            sel = 0;
          if (sel >= cnt)
            sel = cnt - 1;
          lv_roller_set_selected(ui->rollerType, sel, LV_ANIM_ON);
        }
        break;
      }
      case State::RUN: {
        break;
      }
      case State::ERROR: {
        break;
      }
      case State::IDLE: {
        if (dir > 0) { // nächstes Widget den focus geben
          EVENT_DBG("1 Focus next...");
          lv_group_focus_next(ui->group);
          EVENT_DBG("2 Focus next...");
        } else { // vorherigem Widget den Focus zurück geben
          lv_group_focus_prev(ui->group);
          EVENT_DBG("Focus prev..");
        }
        break;
      }
      default:
        if (dir > 0) {
          Serial.println("default focus next...");
          lv_group_focus_next(ui->group);
        }
      } // switch
    }
  } // pollPositionChange
}