// ESP32-S3 HMI (ESP32-1732S019N) + ST7789 170x320 (SPI) + LVGL 9 (Landscape, NO TOUCH)

#include <Arduino.h>
#include <Arduino_GFX_Library.h>
#include <lvgl.h>
#include <esp_timer.h>
#include <esp_heap_caps.h>

// --- Pins ---
#define LCD_DC 11
#define LCD_CS 10
#define LCD_SCK 12
#define LCD_MOSI 13
#define LCD_RST 1
#define LCD_BL 14

// ST7789 logical size (controller base in portrait)
#define LCD_WIDTH 170
#define LCD_HEIGHT 320

// Arduino_GFX bus + panel:
// IMPORTANT: Provide BOTH offset pairs -> (rot0/2) THEN (rot1/3).
// For 170x320: portrait (rot0/2) -> (35,0); landscape (rot1/3) -> (0,35).
Arduino_DataBus *bus = new Arduino_ESP32SPI(LCD_DC, LCD_CS, LCD_SCK, LCD_MOSI, GFX_NOT_DEFINED);
// Arduino_GFX *gfx = new Arduino_ST7789(
//     bus, LCD_RST, 1 /* rotation = landscape */, true /* IPS */,
//     LCD_WIDTH, LCD_HEIGHT,
//     0 /* col off rot0/2 */, 0 /* row off rot0/2 */,
//     0 /* col off rot1/3 */, 0 /* row off rot1/3 */
// );

Arduino_GFX *gfx = new Arduino_ST7789(
    bus, LCD_RST, 1, true,
    170, 320,
    35, 0, // rot0/2
    0, 35  // rot1/3
);

// LVGL globals
static lv_display_t *disp = nullptr;
static lv_obj_t *label_fps = nullptr;
static lv_obj_t *label_slider_val = nullptr;
static lv_obj_t *arc = nullptr;
static lv_obj_t *chart = nullptr;
static lv_chart_series_t *ser = nullptr;

// simple FPS counter
static volatile uint32_t g_frame_count = 0;

// LVGL -> Panel flush
// LVGL -> Panel flush (synchron, verhindert Dirty-Block-Artefakte)
static void flush_cb(lv_display_t *d, const lv_area_t *a, uint8_t *px)
{
    const uint32_t w = a->x2 - a->x1 + 1;
    const uint32_t h = a->y2 - a->y1 + 1;

    gfx->startWrite();
    // Debug: Rahmen füllen, um Altpixel auszuschließen (nur testweise)
    gfx->fillRect(a->x1, a->y1, w, h, BLACK);
#if (LV_COLOR_16_SWAP != 0)
    // LVGL speichert geswapped -> Big-Endian Pfad
    gfx->draw16bitBeRGBBitmap(a->x1, a->y1, reinterpret_cast<uint16_t *>(px), w, h);
#else
    // LVGL speichert little-endian -> normaler RGB-Pfad
    gfx->draw16bitRGBBitmap(a->x1, a->y1, reinterpret_cast<uint16_t *>(px), w, h);
#endif
    gfx->endWrite();

    lv_display_flush_ready(d);
    g_frame_count++;
}
// 1 ms LVGL tick
static void tick_cb(void *) { lv_tick_inc(1); }

// -------------------- UI --------------------
static void ui_build()
{
    uint16_t scr_w = lv_display_get_horizontal_resolution(lv_display_get_default());
    uint16_t scr_h = lv_display_get_vertical_resolution(lv_display_get_default());

    lv_obj_set_style_bg_opa(lv_screen_active(), LV_OPA_COVER, 0);
    lv_obj_set_style_bg_color(lv_screen_active(), lv_color_black(), 0);

    // Header + FPS
    lv_obj_t *hdr = lv_label_create(lv_screen_active());
    lv_label_set_text(hdr, "ESP32-S3 HMI • LVGL 9");
    lv_obj_align(hdr, LV_ALIGN_TOP_MID, 0, 2);

    label_fps = lv_label_create(lv_screen_active());
    lv_label_set_text(label_fps, "FPS: --");
    lv_obj_align(label_fps, LV_ALIGN_TOP_RIGHT, -4, 2);

    // Tabview (left bar fits landscape well)
    lv_obj_t *tabs = lv_tabview_create(lv_screen_active());
    lv_tabview_set_tab_bar_position(tabs, LV_DIR_TOP);
    lv_tabview_set_tab_bar_size(tabs, 24);
    lv_obj_set_size(tabs, scr_w, scr_h - 24);
    lv_obj_align(tabs, LV_ALIGN_BOTTOM_MID, 0, 0);

    // Content background opaque + no scrollbars
    lv_obj_t *content = lv_tabview_get_content(tabs);
    lv_obj_set_style_bg_opa(content, LV_OPA_COVER, 0);
    lv_obj_set_style_bg_color(content, lv_color_black(), 0);
    lv_obj_set_scrollbar_mode(content, LV_SCROLLBAR_MODE_OFF);

    lv_obj_t *tab1 = lv_tabview_add_tab(tabs, "Controls");
    lv_obj_t *tab2 = lv_tabview_add_tab(tabs, "Gauge");
    lv_obj_t *tab3 = lv_tabview_add_tab(tabs, "Chart");

    for (lv_obj_t *p : {tab1, tab2, tab3})
    {
        lv_obj_set_style_bg_opa(p, LV_OPA_COVER, 0);
        lv_obj_set_style_bg_color(p, lv_color_black(), 0);
        lv_obj_set_scrollbar_mode(p, LV_SCROLLBAR_MODE_OFF);
    }

    // --- Controls tab ---
    lv_obj_t *slider = lv_slider_create(tab1);
    lv_obj_set_width(slider, scr_w - 60);
    lv_obj_align(slider, LV_ALIGN_TOP_MID, 0, 6);

    label_slider_val = lv_label_create(tab1);
    lv_label_set_text(label_slider_val, "Value: 0");
    lv_obj_align(label_slider_val, LV_ALIGN_TOP_MID, 0, 28);

    lv_obj_add_event_cb(slider, [](lv_event_t *e)
                        {
    lv_obj_t *sl = (lv_obj_t*)lv_event_get_target(e);
    int v = lv_slider_get_value(sl);
    static char buf[24];
    snprintf(buf, sizeof(buf), "Value: %d", v);
    lv_label_set_text(label_slider_val, buf); }, LV_EVENT_VALUE_CHANGED, nullptr);

    lv_obj_t *sw = lv_switch_create(tab1);
    lv_obj_align(sw, LV_ALIGN_BOTTOM_LEFT, 4, -6);
    lv_obj_t *lbl_sw = lv_label_create(tab1);
    lv_label_set_text(lbl_sw, "Switch");
    lv_obj_align_to(lbl_sw, sw, LV_ALIGN_OUT_RIGHT_MID, 6, 0);

    lv_obj_t *btn = lv_btn_create(tab1);
    lv_obj_align(btn, LV_ALIGN_BOTTOM_RIGHT, -6, -6);
    lv_obj_t *lbl_btn = lv_label_create(btn);
    lv_label_set_text(lbl_btn, "Click");
    lv_obj_center(lbl_btn);

    static int clicks = 0;
    lv_obj_add_event_cb(btn, [](lv_event_t *e)
                        {
    clicks++;
    lv_obj_t *b = (lv_obj_t*)lv_event_get_target(e);
    lv_obj_t *lbl = lv_obj_get_child(b, 0);
    char t[32]; snprintf(t, sizeof(t), "Click (%d)", clicks);
    lv_label_set_text(lbl, t); }, LV_EVENT_CLICKED, nullptr);

    // Slider animation (so tab 1 is alive)
    lv_timer_create([](lv_timer_t *)
                    {
    static int v = 0, dir = 1;
    v += dir * 2;
    if (v >= 100 || v <= 0) dir = -dir;
    lv_arc_set_value(arc, v);
    // label under arc
    lv_obj_t *parent = lv_obj_get_parent(arc);
    lv_obj_t *lbl = lv_obj_get_child(parent, 1);
    char tt[8]; snprintf(tt, sizeof(tt), "%d", v);
    lv_label_set_text(lbl, tt);
    // bar (child 2)
    lv_obj_t *bar2 = lv_obj_get_child(parent, 2);
    lv_bar_set_value(bar2, v, LV_ANIM_OFF); }, 50, nullptr);

    // Gauge (Arc + Label + Bar)
    arc = lv_arc_create(tab2);
    lv_obj_set_size(arc, scr_h - 30, scr_h - 30);
    lv_obj_align(arc, LV_ALIGN_LEFT_MID, 8, 0);
    lv_arc_set_range(arc, 0, 100);
    lv_arc_set_bg_angles(arc, 135, 45);
    lv_arc_set_value(arc, 0);

    lv_obj_t *arc_label = lv_label_create(tab2);
    lv_label_set_text(arc_label, "0");
    lv_obj_align_to(arc_label, arc, LV_ALIGN_OUT_BOTTOM_MID, 0, 4);

    lv_obj_t *bar = lv_bar_create(tab2);
    lv_obj_set_size(bar, scr_w - (36 + (scr_h - 30) + 24), 12);
    lv_obj_align(bar, LV_ALIGN_RIGHT_MID, -8, 0);
    lv_bar_set_range(bar, 0, 100);
    lv_bar_set_value(bar, 0, LV_ANIM_OFF);

    // Timer keeps explicit references instead of child indices
    struct GaugeRefs
    {
        lv_obj_t *arc;
        lv_obj_t *label;
        lv_obj_t *bar;
    };
    static GaugeRefs gauge_refs;
    gauge_refs.arc = arc;
    gauge_refs.label = arc_label;
    gauge_refs.bar = bar;

    lv_timer_create([](lv_timer_t *t)
                    {
    auto *r = static_cast<GaugeRefs*>(lv_timer_get_user_data(t));
    static int v = 0, dir = 1;
    v += dir * 2;
    if (v >= 100 || v <= 0) dir = -dir;

    lv_arc_set_value(r->arc, v);
    char buf[8]; snprintf(buf, sizeof(buf), "%d", v);
    lv_label_set_text(r->label, buf);
    lv_bar_set_value(r->bar, v, LV_ANIM_OFF); }, 50, &gauge_refs);

    // --- Chart tab ---
    chart = lv_chart_create(tab3);
    lv_obj_set_size(chart, scr_w - 50, scr_h - 26);
    lv_obj_align(chart, LV_ALIGN_RIGHT_MID, -6, 0);
    lv_chart_set_type(chart, LV_CHART_TYPE_LINE);
    lv_chart_set_range(chart, LV_CHART_AXIS_PRIMARY_Y, 0, 100);
    lv_chart_set_point_count(chart, 64);
    ser = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_CYAN), LV_CHART_AXIS_PRIMARY_Y);
    lv_obj_set_style_bg_opa(chart, LV_OPA_COVER, 0);
    lv_obj_set_style_bg_color(chart, lv_color_black(), 0);
    lv_obj_set_scrollbar_mode(chart, LV_SCROLLBAR_MODE_OFF);

    lv_timer_create([](lv_timer_t *)
                    {
    static int t = 0;
    int y = (int)(50 + 40 * sinf(t * 0.18f));
    lv_chart_set_next_value(chart, ser, y);
    t++; }, 40, nullptr);

    // FPS label update
    lv_timer_create([](lv_timer_t *)
                    {
    static uint32_t last = 0;
    uint32_t now = g_frame_count;
    uint32_t fps2 = (now - last) * 2; // 500 ms
    last = now;
    if (label_fps) {
      char buf[24];
      snprintf(buf, sizeof(buf), "FPS: %lu", (unsigned long)fps2);
      lv_label_set_text(label_fps, buf);
    } }, 500, nullptr);

    // Auto-rotate tabs (no touch)
    lv_timer_create([](lv_timer_t *t)
                    {
    lv_obj_t *tabs_obj = (lv_obj_t*)lv_timer_get_user_data(t);
    static uint8_t idx = 0;
    idx = (idx + 1) % 3;
    lv_tabview_set_act(tabs_obj, idx, LV_ANIM_ON); }, 3000, tabs);
}

void setup()
{
    Serial.begin(115200);
    delay(20);

    pinMode(LCD_BL, OUTPUT);
    digitalWrite(LCD_BL, HIGH);

    // Start display (60 MHz is a good stable baseline)
    if (!gfx->begin(60000000))
    {
        Serial.println("GFX begin failed");
        while (1)
            delay(100);
    }
    gfx->invertDisplay(true); // set to false if colors look wrong
    gfx->fillScreen(BLACK);

    gfx->invertDisplay(false); // für den Test neutral
    gfx->fillScreen(BLACK);

    // --- Geometrie-Test: Rahmen + Markierungen ---
    uint16_t W = gfx->width();  // sollte 320 sein
    uint16_t H = gfx->height(); // sollte 170 sein

    // 2px Magenta-Rahmen rundum
    gfx->drawRect(0, 0, W, H, 0xF81F);
    gfx->drawRect(1, 1, W - 2, H - 2, 0xF81F);

    // linke Kante: 3 vertikale Linien (rot, grün, blau)
    gfx->drawFastVLine(0, 0, H, 0xF800);
    gfx->drawFastVLine(1, 0, H, 0x07E0);
    gfx->drawFastVLine(2, 0, H, 0x001F);

    // rechte Kante: 3 vertikale Linien
    gfx->drawFastVLine(W - 1, 0, H, 0xF800);
    gfx->drawFastVLine(W - 2, 0, H, 0x07E0);
    gfx->drawFastVLine(W - 3, 0, H, 0x001F);

    // oben/unten: Mittel-Markierungen
    gfx->drawFastHLine(0, 0, W, 0xFFFF);
    gfx->drawFastHLine(0, H - 1, W, 0xFFFF);

    delay(1500); // 1.5 s sichtbar lassen

    // LVGL init
    lv_init();

    // Rotation-aware resolution (landscape -> 320x170)
    uint16_t scr_w = gfx->width();
    uint16_t scr_h = gfx->height();

    // LVGL display with DMA-capable internal double buffers
    disp = lv_display_create(scr_w, scr_h);
    lv_display_set_render_mode(disp, LV_DISPLAY_RENDER_MODE_FULL);
    lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);

    const uint32_t buf_pixels = scr_w * 40; // ~40 lines
    const size_t buf_bytes = buf_pixels * sizeof(lv_color_t);

    lv_color_t *buf1 = (lv_color_t *)heap_caps_malloc(buf_bytes,
                                                      MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA | MALLOC_CAP_8BIT);
    lv_color_t *buf2 = (lv_color_t *)heap_caps_malloc(buf_bytes,
                                                      MALLOC_CAP_INTERNAL | MALLOC_CAP_DMA | MALLOC_CAP_8BIT);
    if (!buf1 || !buf2)
    {
        Serial.println("LVGL DMA buffer alloc failed");
        while (1)
            delay(100);
    }

    lv_display_set_buffers(disp, buf1, buf2, buf_bytes, LV_DISPLAY_RENDER_MODE_PARTIAL);
    lv_display_set_flush_cb(disp, flush_cb);

    // Dummy pointer input (no touch)
    lv_indev_t *indev = lv_indev_create();
    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(indev, [](lv_indev_t *, lv_indev_data_t *d)
                         { d->state = LV_INDEV_STATE_RELEASED; });

    // 1 ms LVGL tick via esp_timer
    const esp_timer_create_args_t tcfg = {.callback = &tick_cb, .name = "lv_tick"};
    esp_timer_handle_t tick;
    esp_timer_create(&tcfg, &tick);
    esp_timer_start_periodic(tick, 1000);

    ui_build();
}

void loop()
{
    lv_timer_handler();
    delay(5);
}